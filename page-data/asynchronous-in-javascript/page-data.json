{"componentChunkName":"component---src-templates-page-js","path":"/asynchronous-in-javascript","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Asynchronous in Javascript","date":"17 March 2020","path":"/asynchronous-in-javascript","author":"James","excerpt":"Javascript is a single-threaded, and all codes are executed in a sequence, not in a parallel fashion. In other words, unlike other languages such as Java, there is only one thread in Javascript, and it can be blocked by an expensive operation.","tags":["javascript","programming"],"coverImage":null},"id":"2dbf09d6-4200-56d9-ac51-825f1eaab593","html":"<h2>Prerequisite</h2>\n<p>Javascript is a single-threaded, and all codes are executed in a sequence, not in a parallel fashion. In other words, unlike other languages such as Java, there is only one thread in Javascript, and it can be blocked by an expensive operation. (For example, when you call API to retrieve data or CRUD operations, it takes time). To overcome this situation, the concept of asynchronous is useful and must be used.</p>\n<h2>Description</h2>\n<p>Asynchronous methods are handy as we do not wait for an operation to be completed before going forward. Once it is finished, the result will be returned and codes can be executed based on the response. In Javascript, we can use <code class=\"language-text\">callback</code>, <code class=\"language-text\">Promise</code> and/or <code class=\"language-text\">async / await</code> to do asynchronous operations.</p>\n<ul>\n<li>Note: Asynchronous implies executing one line, but not waiting for it to be returned. It is not equivalent to <a href=\"https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/\">Concurrency</a> or <a href=\"https://www.geeksforgeeks.org/introduction-to-parallel-computing/\">Parallelism</a></li>\n</ul>\n<hr>\n<h2>Callback</h2>\n<h3>Description</h3>\n<p>Callback is the beginning point of an asynchronous operation in Javascript. In brief, developers and engineers implement callback in a function so that it can be called once a time-consuming operation is finished. </p>\n<h3>Example 1</h3>\n<p>In the first example, <code class=\"language-text\">alert</code> will be executed, and further operation will be done in the <code class=\"language-text\">second</code> function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function first(callback) {\n    alert(&quot;Hi there. How are you doing today?&quot;);\n    callback();\n}\n\nfunction second() {\n    alert(&quot;I am doing great. How about you?&quot;);\n}\n\nfirst(second);</code></pre></div>\n<p>Note that <code class=\"language-text\">second</code> in <code class=\"language-text\">first(second)</code> is not followed by parenthesis.</p>\n<h3>Example 2</h3>\n<p>In the second example, assume that we called an API. Based on the result, we will pass it to the next function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function first(callback) {\n    callApi(..., function(names) {\n        let firstName = names.split(&quot; &quot;)[0];\n        let lastName = names.split(&quot; &quot;)[1];\n        callback(firstName, lastName);\n    })\n}\n\nfunction second(firstName, lastName) {\n    alert(&quot;Hello, firstName + &quot; &quot; + lastName);\n}</code></pre></div>\n<p>Nested callbacks are possible, but it is hard to read.</p>\n<h3>Callback hell</h3>\n<p>Therefore, we say it is a callback hell. To solve this, <code class=\"language-text\">Promise</code> or <code class=\"language-text\">async / await</code> can be used.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">city.getWardList(cityName, function(ward, err) {\n    if (err) console.log(err);\n    else {\n        wards.forEach(function(ward, index) {\n            ward.getSchoolIds(ids, function(res, err) {\n                ids.forEach(function(id, index) {\n                    schoolList.getSchoolNameById(id, function(name) {\n                        ...\n                    })\n                }))\n            })\n        }) \n    }\n})</code></pre></div>\n<hr>\n<h2>Promise</h2>\n<h3>Description</h3>\n<p>Another method for asynchronous operation is a <code class=\"language-text\">Promise</code>. It returns another a state of <code class=\"language-text\">Promise</code> (pending, fulfilled or rejected) in a synchronous fashion, and it supplies the final (return) value when available. Let's see more through examples.</p>\n<ul>\n<li>NOTE: <code class=\"language-text\">Promise</code> is not working on Internet Explorer</li>\n</ul>\n<h3>Example 1</h3>\n<p>The below example is based on <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\">MDN article</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const promise1 = new Promise(function(resolve, reject) {\n    resolve(&#39;Success!&#39;);\n});\n\npromise1.then(function(value) {\n    console.log(value); // &quot;Success!&quot;\n});\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n    setTimeout(resolve, 3000, &#39;It is resolved now&#39;);\n});\n\npromise2.then(result =&gt; {\n    alert(result);\n});</code></pre></div>\n<p><code class=\"language-text\">promise1</code> shows how <code class=\"language-text\">Promise</code> resolves an object (in this case, String), and shows a result via <code class=\"language-text\">console.log</code>. <code class=\"language-text\">promise2</code> is almost the same as <code class=\"language-text\">promise1</code>, arrow functions are used for a reference. After 3 seconds, it is resolved, putting a parameter, 'It is resolved now' in the function.</p>\n<h3>Example 2</h3>\n<p>Example 2 focuses on Promise chaining.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const powerOfTwo = number =&gt; {\n    \n    return Promise.resolve(2 * number);\n}\n\nPromise.resolve(0).then(powerOfTwo) // 1 \n                  .then(powerOfTwo) // 2\n                  ...               // 4\n                  .catch(error =&gt; alert(error))\n                  .finally(result =&gt; {\n                      console.log(result);\n                  })</code></pre></div>\n<p><code class=\"language-text\">powerOfTwo</code> is a function for nth power of 2. The important parts are <code class=\"language-text\">then</code>, <code class=\"language-text\">catch</code> and <code class=\"language-text\">finally</code>. <code class=\"language-text\">then</code> is used to receive a return value, and <code class=\"language-text\">catch</code> is called when there is an error. Two ways to use <code class=\"language-text\">catch</code> inside a <code class=\"language-text\">promise</code> are suggested.</p>\n<ul>\n<li>\n<p>Inside of promise, throw <code class=\"language-text\">Error</code>. For example,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">new Promise((resolve, reject) =&gt; {\nthrow new Error(&quot;Encountered an error&quot;);\n}));</code></pre></div>\n</li>\n<li>\n<p>OR, <code class=\"language-text\">reject</code> it</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">new Promise((resolve, reject) =&gt; {\nreject(new Error(&quot;Encountered an error&quot;));\n}) </code></pre></div>\n</li>\n</ul>\n<p>Last but not least, <code class=\"language-text\">finally</code> can be used so that some actions must be taken whether all code is executed with or without a problem.</p>\n<h3>Promise.all</h3>\n<p>One of the strengths in using Promise is that we can do multiple asynchronous operations in a parallel manner (please check the note as well). This also implies that we can easily identify and solve a problem when any of the <code class=\"language-text\">Promise</code> is failed.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const promise1 = updateUserProfile(userID, options);\nconst promise2 = updateDocument(userID, options);\n\nPromise.all([promise1, promise2]).then(values =&gt; {\n    console.log(values);\n})</code></pre></div>\n<h3>NOTE</h3>\n<ul>\n<li>Until I wrote this, I thought Promise.all always run things in parallel. <a href=\"https://anotherdev.xyz/promise-all-runs-in-parallel/\">It was so surprising to know that it is not guaranteed, even though a single-core CPU is not popular anymore.</a></li>\n</ul>\n<hr>\n<h2>Async &#x26; Await</h2>\n<h3>Description</h3>\n<p>The final method I will introduce is Async &#x26; Await. While each developer and engineer chooses a different method depending on their preference and circumstance they encounter, I prefer using Async &#x26; Await as it is more straightforward.</p>\n<h3>Example 1</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function hello() {\n    let result = await fetch(&quot;........&quot;);\n    let user = await result.json();\n}\n\nasync function world() {\n    return &quot;hello world&quot;;\n}</code></pre></div>\n<p>As you see from the above, <code class=\"language-text\">async</code> is mandatory if you need to use <code class=\"language-text\">await</code> for an asynchronous operation. However, <code class=\"language-text\">async</code> does not always need <code class=\"language-text\">await</code>. </p>\n<h3>Example 2</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const example = async () =&gt; {\n    let promiseVariable = new Promise((resolve, reject) =&gt; {\n        resolve(&quot;hi there&quot;);\n    });\n\n    let result = await promiseVariable;\n}</code></pre></div>\n<h3>Example 3</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const asyncFunction = async () =&gt; {\n    const docs = await getDocuments();\n    const newValue = &quot;...&quot;;\n\n    Promise.all(\n        docs.map(async doc =&gt; {\n            const serverTime = await getServerTime();\n            \n            const result = await updateDoc(doc, newValue, serverTime);\n        })\n    )\n}</code></pre></div>\n<p>Through example 2 and example 3, we can find that <code class=\"language-text\">Promise.all</code> with <code class=\"language-text\">async</code> and <code class=\"language-text\">await</code> can be used together, and it is quite useful to do multiple asynchronous operation clearly and efficiently.</p>","excerpt":"Prerequisite Javascript is a single-threaded, and all codes are executed in a sequence, not in a parallel fashion. In other words, unlike…"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":"/deploying-react-spa-in-10-minutes-using-azure","title":"Deploying React SPA in 10 Minutes using Azure","tags":["azure","react","cloud","programming"]},"fileAbsolutePath":"/Users/james/Development/Git/jyoo/src/posts/2020-03-11-deploying-react-spa-in-10-mins-using-azure.md"},"previous":{"frontmatter":{"path":"/react-state-management-and-life-cycle-part-1","title":"React State Management And Life Cycle - Part 1","tags":["react","programming"]},"fileAbsolutePath":"/Users/james/Development/Git/jyoo/src/posts/2020-04-02-react-state-management-and-life-cycle-part-1.md"}}}}