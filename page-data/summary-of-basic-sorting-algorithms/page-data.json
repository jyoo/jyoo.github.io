{"componentChunkName":"component---src-templates-page-js","path":"/summary-of-basic-sorting-algorithms","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Summary of Basic Sorting Algorithms","date":"23 April 2020","path":"/summary-of-basic-sorting-algorithms","author":"James","excerpt":"Understanding algorithms and knowing how to use them is the key in computer science and software engineering. While we know the importance of learning algorithms, many people (including me) have a hard time doing it, and they often give up in the middle of learning.","tags":["algorithm","algorithm-ds"],"coverImage":null},"id":"03476da0-7c9f-5847-8763-038901759a11","html":"<p>Understanding algorithms and knowing how to use them is the key in computer science and software engineering. While we know the importance of learning algorithms, many people (including me) have a hard time doing it, and they often give up in the middle of learning.</p>\n<p>When we google algorithms and data structures, I see many excellent articles and writings, but they are somewhat burdensome at first to read from the beginning to the end. That's why I created this writing. In this writing, I write a summary of basic sorting algorithms: 1) Selection sort 2) Bubble sort and 3) Insertion sort so that anyone who does not have any or limited knowledge of algorithms can easily start.</p>\n<hr>\n<h1>Algorithm</h1>\n<ul>\n<li>\n<p>A set of instructions </p>\n<ul>\n<li>\n<p>In particular, it is about: </p>\n<ul>\n<li>What a program needs to do, and</li>\n<li>How the program has to solve</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>The two important keywords for the computers: \"efficiency\" and \"tradeoffs\".</p>\n<ul>\n<li>To measure how efficient it is and know what we gain and lose, \"Big O notation is used\"</li>\n</ul>\n</li>\n<li>\n<p>Big O notation is about:</p>\n<ul>\n<li>How much time it needs (the time complexity of an algorithm)</li>\n<li>How much memory it needs (the space complexity of an algorithm)</li>\n<li>\n<p>NOTE: By using Big O notation, we ignore external factors because it is hard to tell.</p>\n<ul>\n<li>For example, the speed of a processor</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Big O</h1>\n<ul>\n<li>\n<p>O(1)</p>\n<ul>\n<li>\"Constant time\"</li>\n<li>Regardless of a size of inputs <code class=\"language-text\">n</code>, a O(1) function always takes constant time.</li>\n</ul>\n</li>\n<li>O(logn)</li>\n<li>\n<p>O(n)</p>\n<ul>\n<li>\"Linear time\"</li>\n<li>As a size of inputs grows, the complexity grows linearly as well.</li>\n</ul>\n</li>\n<li>O(n logn)</li>\n<li>\n<p>O(n^k)</p>\n<ul>\n<li>When <code class=\"language-text\">k = 2</code>, we say it grows quadratically</li>\n</ul>\n</li>\n<li>O(k^n)</li>\n</ul>\n<hr>\n<h1>Sorting Algorithm</h1>\n<h2>Definition</h2>\n<ul>\n<li>Sorting is an organizing a set of items in a collection by some properties</li>\n</ul>\n<h2>Goal</h2>\n<ul>\n<li>Making it easier to search, retrieve and read data</li>\n</ul>\n<h2>Criteria</h2>\n<ul>\n<li>Time complexity</li>\n<li>\n<p>Space complexity (memory usage)</p>\n<ol>\n<li>In-place algorithm: sort the existing dataset (= a risky operation)</li>\n<li>Out-of-place algorithm: making new copy and sort it</li>\n</ol>\n</li>\n<li>\n<p>Stability</p>\n<ul>\n<li>An algorithm is stable when the \"relative order\" of the elements is kept.</li>\n<li>For example, say that there is [1, 1, 3, 2, 4]</li>\n<li>If the first 1 and second 1 does not change their order, it is stable</li>\n</ul>\n</li>\n<li>\n<p>Internal vs. External</p>\n<ul>\n<li>It is internal if applicable data can be kept in main memory</li>\n</ul>\n</li>\n<li>Recursive vs. Non-recursive</li>\n<li>\n<p>Comparison vs. Non-comparison</p>\n<ul>\n<li>There exists a comparison if a comparator is used to compare two items</li>\n</ul>\n</li>\n</ul>\n<h3>NOTE</h3>\n<ul>\n<li>We can sort in increasing (i.e, non-decreasing) or decreasing order (by a property)</li>\n<li>Items in a given dataset must be homogeneous (i.e, a comparison between numbers or between strings)</li>\n</ul>\n<hr>\n<h1>Selection Sort</h1>\n<h2>Definition</h2>\n<ul>\n<li>A selection sort algorithm is an algorithm that finds the smallest item and put it in a sorted list.</li>\n</ul>\n<h2>Pros</h2>\n<ul>\n<li>Good to use if it is for a very small dataset</li>\n<li>Easy to implement</li>\n</ul>\n<h2>Cons</h2>\n<ul>\n<li>Not efficient (Time complexity: O(n^2)) </li>\n</ul>\n<h2>How to</h2>\n<ol>\n<li>Compare a value of first item with values of rest of the items (i.e, from second to the end)</li>\n<li>If there is an item with a smaller value compare with the first item, switch their position</li>\n<li>Keep the very first item, and do comparison between the second item and the rest of items.</li>\n<li>Switch the position of second item and an item with smaller value (than the second one), if applicable</li>\n<li>Stops after the last element</li>\n</ol>\n<h2>Code</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// JS\nfunction selectionSort(items) {\n\n    // NOTE: If shallow copy is satisfactory\n    let clonedItems = items.slice();\n    let length = clonedItems.length;\n    \n\n    for (let i = 0; i &lt; length; i++) {\n\n        let selectedItemIndex = i;\n\n        for (let j = i + 1; j &lt; length; j++) {\n            if (clonedItems[i] &gt; clonedItems[j]) selectedItemIndex = j;\n        }\n\n        if (selectedItemIndex != i) {\n            let temp = clonedItems[i];\n\n            clonedItems[i] = clonedItems[selectedItemIndex];\n            clonedItems[selectedItemIndex] = temp;\n        }\n    }\n\n    return clonedItems\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// TS\n\n// Java\n\n// Python</code></pre></div>\n<hr>\n<h1>Bubble Sort</h1>\n<hr>\n<h1>Insertion Sort</h1>","excerpt":"Understanding algorithms and knowing how to use them is the key in computer science and software engineering. While we know the importanceâ€¦"}},"pageContext":{"type":"posts","next":{"frontmatter":{"path":"/react-state-management-and-life-cycle-part-2","title":"React State Management And Life Cycle - Part 2","tags":["react","programming"]},"fileAbsolutePath":"/Users/james/Development/Git/jyoo/src/posts/2020-04-21-react-state-management-and-life-cycle-part-2.md"},"previous":{"frontmatter":{"path":"/slugify-in-python","title":"Slugify In Python","tags":["python","programming"]},"fileAbsolutePath":"/Users/james/Development/Git/jyoo/src/posts/2020-05-04-slugify-in-python.md"}}}}